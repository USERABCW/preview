#  绪论

## **数据库4个基本概念**

1.**数据data：描述事物的符号，数据库中存储的基本对象**

2.**数据库DataBase,DB：长期存储在计算机内的、有组织的、可共享的大量数据集合**

(1) 具有较小冗余度

(2)较高数据独立性

(3)易扩展性

(4)可为各种用户共享

3.**数据库管理系统(DBMS)：位于用户与操作系统之间的一层数据管理软件**

(1)数据定义功能DDL(数据定义语言)

(2)数据组织,存储和管理

(3)数据操纵功能DML(数据操纵语言)

(4)数据库的事务管理和运行管理

(5)数据库的建立与维护功能

(6)其他功能

4.**数据库系统(DBS):由数据库、数据库管理系统、应用程序和数据库管理员(DBA)组成**

## **数据库系统特点**

(1)数据结构化

(2)数据的共享性高，冗余度低而且容易扩充

(3)数据独立性高

I:物理独立性:应用程序与物理内存相互独立，数据的物理存储改变，应用程序不改变

II:逻辑独立性:应用程序与逻辑结构相互独立，数据逻辑结构改变，应用程序不改变

(4)数据由数据库管理系统统一管理和控制

I:数据安全性保护

II:数据完整性保护

III:并发控制

IV:数据库恢复

## **数据模型**

数据模型包括**概念模型**和**逻辑模型/物理模型**

**概念模型**:现实世界到机器世界的一个中间层次，信息世界的建模(**E-R方法**)——实体-联系方法

**逻辑模型**:按计算机的观点建模，用于DBMS实现，包括网状模型、层次模型、关系模型等等

层次模型是一种数据模型，它以树的形式组织数据，其中数据实体以层次结构表示。每个节点表示一个数据实体，父子节点之间表示实体间的一对多关系。

**网状模型**是一种数据模型，其中数据以图的形式组织，节点表示数据实体，边表示实体之间的关系。网状模型允许多对多的关系，因此比层次模型更灵活。

**关系模型**是一种数据模型，它使用表来组织数据，每个表由行和列组成。行表示记录，列表示属性。关系模型通过表的形式表示实体及其关系，使用主键和外键来连接表。

**物理模型**:对数据最底层的抽象

**组成要素**

(1)**数据结构**:描述系统的**静态特性**->描述数据库的组成对象以及对象之间的联系

(2)**数据操作**:描述系统的**动态特性**->是对数据库中各种对象的实例所允许的操作的集合，其类型有查询和更新(增删改)

(3)**数据完整性约束条件**:用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效与相容，完整型约束条件是一组完整性规则的集合。

## **数据库三级模式结构**

**外模式(子模式/用户模式)**:数据库用户能够看见和使用的**局部数据**的**逻辑结构和特征**的**描述**

**模式**(**逻辑模式**):数据库中**全体数据**的**逻辑结构和特征**的**描述**,所有用户的公共数据视图

**内模式(存储模式)**:数据**物理结构和存储方法**的**描述**,是数据在数据库内部的组织方式

## **数据库的二级映像功能与数据独立性**

**外模式/模式映像**:保证数据的**逻辑独立性**

当模式改变时，对**外模式/模式**的映像做出改变，保证外模式不变，应用程序由外模式编写，从而应用程序不变

**模式/内模式映像**:保证数据的**物理独立性**

当数据库的存储结构改变时，对**模式/内模式**的映像做出改变，使模式不变，进而应用程序不变

# **数据库安全性**

定义：保护数据库以防止**不合法的使用**所造成的**数据泄露、更改或破坏**。

## **数据库不安全因素**：

(1)**非授权用户**对数据库的**恶意存取和破坏**

(2)数据库中**重要数据的泄露**

(3)安全环境的脆弱性

## **数据库安全性控制的常用方法和技术**

(1)用户身份鉴别：静态口令鉴别、动态口令鉴别、生物特征鉴别、智能卡鉴别

(2)多层存取控制

I:**自主存取控制方法(DAC)**:定义各个用户对不同数据对象的存取权限

**创建数据库模式的权限**

I:DBA(超级用户权限)

II:RESOURCE:可以创建**基本表和视图**,但不能创建模式和新用户

III:CONNECT:只能登录数据库

数据库**角色**:**权限的集合**。

II:**强制存取控制方法(MAC)**:每一个**数据对象**被强制地标以一定的**密级**,每一个**用户**也被强制地授予某一个级别的**许可证**

1.**主体**:系统中的**活动实体**,即包括DBMS所管理的实际用户，也包括代表用户的各进程

2.**客体**:系统中的**被动实体**,是受主体操纵的，包括文件、基本表、索引、视图等

(3)视图机制

(4)审计 AUDIT

(5)数据加密

# **数据库完整性**

## **数据库的完整性是指数据的正确性和相容性**

**正确性**:符合现实世界的语义 ————用户自定义完整性

**相容性**:同一对象在不同表中的数据符合逻辑———— 实体完整性和参照完整性

## **数据库完整性约束条件**是指数据库中的数据应该满足的**语义约束条件**

DBMS的完整性控制机制具有哪三个方面的**功能**:

(1):**定义功能**：提供定义完整性约束条件的机制

(2):**检查功能**：检查用户发出的操作请求是否违背了完整性约束条件

(3):**违约处理功能**：如果发现用户的操作请求使数据违背了完整性约束条件，则采取一定的动作来保证数据的完整性

## **三大完整性**

**实体完整性**:主码唯一且非空

**参照完整性**：外码的约束 

处理方式：NO ACTION ； SET NULL ；CASCADE

**用户定义完整性**：属性上约束条件的定义



# **关系数据理论**

## **概念**

**函数依赖**：设 $R(U)$ 是一个关系模式，$U$ 是 $R$ 的属性集合，$X$ 和 $Y$ 是 $U$ 的子集，对于 $R(U)$ 的任意一个可能的关系 $r$，如果 $r$ 中不存在两个元组，他们在 $X$ 上属性值相同，而在 $Y$ 上属性值不同，则有 $X \rightarrow Y$。

**完全函数依赖**：在 $R(U)$ 中，如果 $X \rightarrow Y$，并且对于 $X$ 的任何一个真子集 $X_z$，都有 $X_z \nrightarrow Y$，称 $Y$ 对 $X$ 完全函数依赖，记作 $X \stackrel{F}{\longrightarrow} Y$。

**部分函数依赖**：$Y$ 不完全函数依赖于 $X$，即为 $Y$ 部分函数依赖于 $X$，即 $X \stackrel{P}{\longrightarrow} Y$。

**传递函数依赖**：在关系模式 $R(U)$ 中，如果 $X \rightarrow Y$，且 $Y \rightarrow Z$，并且 $Z$ 不是 $Y$ 的子集，且 $Y$ 不函数决定 $X$，则称 $Z$ 对 $X$ 传递函数依赖（Transitive Functional Dependency）。

**候选码**：$K$ 为 $R \langle U, F \rangle$ 中的属性或属性组合，若 $K \stackrel{F}{\longrightarrow} U$，则 $K$ 为 $R$ 的候选码。

**主码**：候选码中选一个为主码。

**外码**：关系模式 $R$ 中属性或属性组 $X$ 并非 $R$ 的码，但 $X$ 是另一个关系模式的码，称 $X$ 是 $R$ 的外码。

**全码**：整个属性组是码，称为全码。

**1NF**：如果一个关系模式 $R$ 的所有属性都是不可分的基本数据项，则 $R$ 是 1NF。

**2NF**：若关系模式 $R$ 属于 1NF，并且每一个非主属性都完全函数依赖于 $R$ 的码，则 $R$ 属于 2NF。

**3NF**：关系模式 $R \langle U, F \rangle$ 中若不存在这样的码 $X$，属性组 $Y$ 以及非主属性 $Z$（$Z \notin Y$），使得 $X \rightarrow Y$，($Y \nrightarrow X$)，$Y \rightarrow Z$ 成立，则称 $R \langle U, F \rangle$ 属于 3NF。

**BCNF**：关系模式 $R \langle U, F \rangle$ 属于 1NF，若 $X \rightarrow Y$ 且 $Y \not\subseteq X$ 时 $X$ 必含有码，则 $R \langle U, F \rangle$ 属于 BCNF。

**多值依赖**：设 $R(U)$ 是属性集 $U$ 上的一个关系模式，$X, Y, Z$ 是 $U$ 的子集，并且 $Z = U - X - Y$。关系模式 $R(U)$ 中多值依赖 $X \rightarrow\rightarrow Y$ 成立，当且仅当对于 $R(U)$ 的任一关系 $r$，给定的一对 $(x, z)$ 值，有一组 $Y$ 的值，这组值仅仅决定于 $x$ 值而与 $z$ 值无关。

**4NF**：关系模式 $R \langle U, F \rangle$ 属于 1NF，如果对于 $R$ 的每个非平凡多值依赖 $X \rightarrow\rightarrow Y$（$Y \not\subseteq X$），$X$ 都含有码，则称 $R \langle U, F \rangle$ 属于 4NF。

# **数据库设计的步骤**

概念：对于一个给定的应用环境，构造优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统

## 数据库设计方法

新奥尔良方法

基于E-R模型的数据库设计方法

3NF的设计方法

面向对象的数据库设计方法

统一建模语言(UML)方法

## 数据库设计阶段

### 需求分析

**数据字典**：数据收集和数据分析所获得的主要结果，**是关于数据库中数据的描述**，**是下一步概念结构分析的基础**

内容：**数据项 数据结构 数据流 数据存储 处理过程**

### 概念结构分析

**将需求分析得到的用户需求抽象为概念模型的过程**

特点：

是**现实世界的一个真实模型**，映射

**易于理解**，可以与用户交换意见

概念模型**容易修改和扩充**

**易于向关系、网状、层次等各种数据模型转换**

E-R模型

**实体:** 客观存在并可以相互区分的事物

**实体型:**具有相同属性的实体具有相同的特征和性质

**实体集:**同型实体的集合称为实体集

**属性**:实体所具有的某种特性

**码:**唯一标识实体的属性集称为码

E-R图集成

​	**合并**：解决各分E-R图之间的**冲突**(命名冲突、属性冲突、结构冲突)，生成初步E-R图

​	**修改和重构：**消除不必要的冗余，生成基本E-R图

### 逻辑结构分析

E-R图转换为关系模型

**关系模式的个数=实体集的个数+多对多联系的个数**

I:一个1:1的联系可以转化为一个独立的关系模式，也可以与任意一端对应的关系模式合并

II:一个1:n的联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并

III:一个m:n联系可以转换为一个关系模式

IV:三个或三个以上实体间的一个多元联系可以转化为一个关系模式

优化

水平分解

垂直分解

### 数据库物理设计

数据库在物理设备上的**存储结构**与**存取方法**称为数据库的物理结构

设计步骤

**确定数据库物理结构**，在关系数据库中主要指存取方法和存储结构

**对物理结构进行评价**，时间和空间效率

### 数据库实施

### 数据库运行和维护



# 数据库恢复技术

## **事务**

**概念**：数据库操作序列，这些操作要么全做，要么全不做，是不可分割的工作单位。

**事务是恢复的基本单位，也是并发控制的基本单位。**

事务的ACID特性

**原子性**：事务中包括的诸操作要么都做，要么都不做

**一致性：**事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态

**隔离性：**并发执行的各个事务之间不能互相干扰

**持续性：**一个事务一旦提交，它对数据库中数据的改变就应该是永久性的

## 恢复

故障的影响

故障是不可避免的

造成事务非正常中断，数据库全部或部分丢失数据

1.事务内部的故障

软故障

事务没有达到预期的终点（COMMIT或者显示ROLLBACK）

事务撤销（UNDO）：强行回滚（ROLLBACK）该事务————无需重做已提交的事务

2，系统故障

软故障

系统重新启动时，恢复程序让所有非正常终止的事务回滚，强行撤销（UNDO）所有未完成的事务

恢复策略：系统重新启动时，恢复程序需要重做（REDO）所有已提交的事务

3.介质故障

4.计算机病毒

3.4可能是硬故障——数据库恢复

恢复操作的基本原理：**冗余**

利用存储在系统别处的**冗余数据**来**重建**数据库中已被破坏或不正确的那部分数据

**转储：**数据库管理员定期将整个数据库复制到存储介质上保存起来的过程，备用的数据称为**后备副本**

**转储状态**

​	静态转储

​	动态转储

**转储方式**

​	海量转储

​	增量转储

**日志文件**：用来记录事务对数据库的更新操作的文件

​	![image-20240519175657658](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20240519175657658.png)

为什么要先写日志文件

在写日志文件和写操作库之间可能发生故障

如果先写数据库修改，而在日志文件中没有登记下这个修改，则以后就无法恢复这个修改了

如果先写日志，但没有修改数据库，则恢复时多执行一次UNDO

系统故障恢复策略

**（1）正向扫描日志文件**

**重做（REDO）队列：即有BEGIN TRANSACTION 也有 COMMIT记录**

**撤销（UNDO）队列：只有BEGIN TRANSACTION 无 COMMIT记录**

**（2）反向扫描日志文件：对UNDO队列事务进行撤销处理**

**（3）正向扫描日志文件：对REDO队列事务进行重做处理**

优化：具有检查点的恢复技术

# 并发控制

**并发操作带来的数据不一致性**

1.**丢失修改**

2.**不可重复读**

3.**读"脏"数据**

并发控制就是要求**用正确的方式调度并发操作，使一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性**

**并发控制的主要技术**

**封锁**

事务T在对某个数据对象操作之前，先向系统发出请求，对其加锁

排他锁：X锁 写锁

共享锁：S锁 读锁

**一级封锁协议（保证没有丢失修改）**

**事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放**

**二级封锁协议（保证不读"脏"数据）**

**一级封锁协议+事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁**

**三级封锁协议（防止不可重复读）**

**一级封锁协议+事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放**

问题：

活锁

处理：先来先服务的策略

死锁

处理：（1）一次封锁法 （2）顺序封锁法

（3）超时法诊断死锁

并行调度的可串行性

串行调度是正确的，执行结果等价于串行调度的调度也是正确的

冲突操作：不同事务对同一数据的读写操作和写写操作

两段锁协议2PL（获得封锁，释放封锁）

指所有事务必须分两个阶段对数据项加锁和解锁

--在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁

--在释放一个封锁之后，事务不在申请和获得任何其他封锁

若并发事务都遵循两段锁协议，则对这些事务的任何并发调度策略都是可串行化的

若并发事务的一个调度是可串行化的，不一定所有事务都符合两段锁协议

**封锁粒度**：封锁对象的大小

意向锁：

意向共享锁：IS锁

意向排他锁：IX锁

共享意向排他锁：SIX锁

**时间戳**

**乐观控制法**

**多版本并发控制（MVCC）**

